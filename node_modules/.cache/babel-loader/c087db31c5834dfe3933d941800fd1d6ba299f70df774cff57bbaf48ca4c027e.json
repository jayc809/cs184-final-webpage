{"ast":null,"code":"var _jsxFileName = \"/Users/jay/Code/CS184/final-website-2/src/App.js\";\n// App.js\nimport React from 'react';\nimport Header from './Header';\nimport Section from './Section';\nimport IMAGES from './images/index1.js';\nimport BP from './images/Ball Pivot.png';\nimport Fish from './images/Poisson.png';\nimport beanOG from './images/beanOriginal.png';\nimport beanReconstructed from './images/beanReconstructed.png';\n// import vid1 from './images/ball radius.mov';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Header, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"Abstract\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \" This report elucidates the ongoing development of a Point Cloud Mesh Reconstruction system, aiming to convert point cloud inputs into usable mesh representations. A point cloud is a collection of points along with surface normals, representing/capturing an implied surface. Hence, the goal of mesh reconstrution is to infer an actual surface, in the form of a triangle mesh, from just the data of a point cloud. We have successfully implemented the Ball Pivot Approximation algorithm (BPA), and have additionally added user functionality for running the algorithm. The project also involves testing the system against a repository of existing 3D mesh models to give a demonstration of the accuracy of the BPA algorithm. Additionally, we tested the algorithm on datasets lacking pre-existing meshes.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 17,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"Technical Approach\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The technical approach primarily revolves around implementing the Ball Pivot Approximation algorithm as outlined in the referenced paper. This algorithm operates by rolling an imaginary ball along the given point cloud, adding triangles to the mesh where the ball touches three points. Our implementation maintains an advancing front of the constructed mesh, meaning there is a boundary of 'active edges,' separating the so-far constructed mesh from the points which are yet to be incoporated into the mesh. We iteratively finding new triangles to add by pivoting along these boundary edges. Key functions include ballPivot for identifying the first point reached during pivoting, findSeedTriangle for initiating a new front if remaining vertices exist, and join and glue for modifying boundary edge topology. We will discuess these one by one.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 20,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \" Firstly, we use the findSeedTriangle function to find a place to initialize the boundary. The important part of finding such a triangle is that the ball defined by the seed triangle must not contain any other point. This search is done in somewhat of a brute force search. Though we ensure to search points that are roughly close to each other, as far away points have a much less likely chance of being valid seed triangles. It should also be noted that findSeedTriangle may be used multiple times if the surface being reconstructed has multiple components. To detect this, we check to see if there are any remaining unused points after the current boundary is finished advancing.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Next, we have the \", /*#__PURE__*/_jsxDEV(\"underline\", {\n          children: \"ballPivot\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 22,\n          columnNumber: 30\n        }, this), \" function. This funtions hosts the geometric heart of the algorithm, and is where most of the mathematical calculations are done. BallPivot takes an edge along the current boundary, and identifies the first point in the point cloud that is hit when a ball is rolled along this edge. This is the first step in adding a triangle to the mesh, as it identifies a candidate triangle to add. However, it is not always the case that we add this triangle to the mesh, as it may introduce nonmanifold topology. \"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 22,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \" Finally, if it is decided that the triangle can successfully be added to the mesh, we must update the current boundary to reflect this change. This is where we use join and glue operations. Join is used to add two new edges around the newly added triangle. However, in some instances, this ill end up with the boundary interesting itself. In this case, we use the glue operation to remove this flaw with the boundary, so that we maintain that the other side of a boundary edge is always outside of the currently constructed mesh. \"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 23,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Besides these functions, we used some data structures to keep track of the details of the algorithm. To start, the point cloud itself is stored as a list of 3D points, and a matching list of surface normals. Throughout the algorithm, we use indices into these lists to refer to points, as opposed to the actual points themselves. This is both for ease of linking a point to its normal, and for the simplicity of identifying points.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 25,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"For the algirithm itself, we used two main data structures. To store the advancing front, we used a list of doubly linked lists of edges. The resaon we need multiple linked lists is that the boundary may split in two during glue operations. Each edge stores its two points, as well as the center of the ball used to define the triangle it is a part of. This center is necessary to know where to start the ball rolling in ballPivot steps. The second data structure we used was a grid of voxels, used for storing the point cloud in a way that allowed for accessing nearby points more easily. Throughout the geometric steps above, (ballPivot and findSeedTriangle), it is only necessary to know the points that are nearby when doing searches. Thus, it would be a large waste of time to do searches across the entire point cloud, when each step is only a local operation. \"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 26,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"img\", {\n        src: BP,\n        alt: \"Ball Pivot Illustration\",\n        style: {\n          display: 'block',\n          margin: '20px auto'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"On the other hand, Poisson surface reconstruction leverages the principles of implicit surface modeling to generate a smooth and continuous mesh from the input point cloud. By formulating the reconstruction problem as a Poisson equation, the algorithm seeks to find a function that best fits the input points while adhering to certain boundary conditions. This approach is particularly adept at handling noisy or incomplete point cloud data, as it inherently incorporates regularization techniques to ensure robustness and fidelity in the reconstructed mesh.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 29,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-container\",\n        children: [/*#__PURE__*/_jsxDEV(\"img\", {\n          src: Fish,\n          alt: \"Poisson reconstruction Illustration\",\n          title: \"Possion\",\n          width: \"1000\",\n          height: \"450\",\n          style: {\n            display: 'block',\n            margin: '20px auto'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 31,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"tooltip\",\n          children: \"Poisson\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 32,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 30,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"Problems Encountered and Solutions:\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"One significant challenge encountered was the debugging process, requiring meticulous attention to detail to resolve issues and ensure the reliability of the algorithm. There were two significant sources for the majority of the difficulty of debugging the algorithm. The first was that for a majority of the algorithm debugging process, we had not yet made a means of visualizing the point cloud itself. This made it difficult to see what was going wrong and to figure out what might be the cause of the mistakes in the algorithm. Once we made a visualization for the point cloud, debugging was significantly sped up. The second cause for headache was a misunderstanding of the polygon mesh to half-edge mesh conversion program we were using out of the box. This led to us trying to fix a problem in the algorithm that didn't exist, per se, when the real issue was a misuse of the mesh visualization aspect of the program.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"As a general approach to tackle these challenges, a systematic approach to debugging and problem-solving was employed, leveraging collaborative efforts within the project team. Regular testing and validation procedures help identify and address issues in a timely manner, ensuring steady progress towards project goals.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Finally, there is a fundamental limitation of the algorithm itself, which has to do with deciding the radius of the ball to use. Essentially, if the radius is too big, then areas of the surface that have tight curvature will not be detected by rolling the ball over (see the image ). Whereas, if the radius is not large enough, it may percieve boundaries of the surface where there aren't any if there are gaps in the point cloud that are bigger than the ball itself.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 40,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"Lessons Learned\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \" Through the development process, valuable lessons have been learned regarding the complexities of mesh reconstruction from point cloud data. The importance of thorough testing and validation, as well as the need for effective communication and collaboration within the project team, has been underscored. Additionally, the iterative nature of algorithm development highlights the significance of adaptability and flexibility in responding to challenges and refining the system. These lessons serve as valuable insights for future projects in the field of point cloud to mesh conversion.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"One important lesson we learned was to devote more time towards planning out the development process before diving straight in to coding the project. Given that we had done this, we would have likely opted to first create a point cloud visualization first, seeing as we could use that for the next step in the development process. Instead, we went first for the interesting, fun part of the project, ultimately leading to a longer and more arduous project experience.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Perhaps another important lesson we learned was a lesson in scope. Initially, we had plans to do much more with the project, though we did not end up accomplishing these goals.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 52,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 44,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"Results\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"The accompanying point cloud viewer demo showcases visualization capabilities, providing insights into the mesh reconstruction process as well as, animations, and videos of the system are also included.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 58,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \" Here is a comparison between an mesh, and the reconstructed mesh obtained by running the algorithm on just the vertices of the original mesh:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 61,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"image-container\",\n          children: [/*#__PURE__*/_jsxDEV(\"img\", {\n            src: beanOG,\n            alt: \"Poisson reconstruction Illustration\",\n            title: \"Original\",\n            width: \"40%\",\n            height: \"40%\",\n            style: {\n              display: 'block',\n              margin: '20px auto'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 64,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"tooltip\",\n            children: \"original\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 65,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 63,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"image-container\",\n          children: [/*#__PURE__*/_jsxDEV(\"img\", {\n            src: beanReconstructed,\n            alt: \"Poisson reconstruction Illustration\",\n            title: \"Reconstructed\",\n            width: \"40%\",\n            height: \"40%\",\n            style: {\n              display: 'block',\n              margin: '20px auto'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 68,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"tooltip\",\n            children: \"reconstructed\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 69,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 67,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Section, {\n      title: \"References\",\n      children: /*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"http://mesh.brown.edu/taubin/pdfs/bernardini-etal-tvcg99.pdf\",\n        children: \" The Ball-Pivoting Algorithm for Surface Reconstruction \"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 76,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 14,\n    columnNumber: 5\n  }, this);\n}\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","Header","Section","IMAGES","BP","Fish","beanOG","beanReconstructed","jsxDEV","_jsxDEV","App","children","fileName","_jsxFileName","lineNumber","columnNumber","title","src","alt","style","display","margin","className","width","height","href","_c","$RefreshReg$"],"sources":["/Users/jay/Code/CS184/final-website-2/src/App.js"],"sourcesContent":["// App.js\nimport React from 'react';\nimport Header from './Header';\nimport Section from './Section';\nimport IMAGES from './images/index1.js';\nimport BP from './images/Ball Pivot.png';\nimport Fish from './images/Poisson.png';\nimport beanOG from './images/beanOriginal.png';\nimport beanReconstructed from './images/beanReconstructed.png';\n// import vid1 from './images/ball radius.mov';\nimport './App.css';\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <Section title=\"Abstract\">\n        <p> This report elucidates the ongoing development of a Point Cloud Mesh Reconstruction system, aiming to convert point cloud inputs into usable mesh representations. A point cloud is a collection of points along with surface normals, representing/capturing an implied surface. Hence, the goal of mesh reconstrution is to infer an actual surface, in the form of a triangle mesh, from just the data of a point cloud. We have successfully implemented the Ball Pivot Approximation algorithm (BPA), and have additionally added user functionality for running the algorithm. The project also involves testing the system against a repository of existing 3D mesh models to give a demonstration of the accuracy of the BPA algorithm. Additionally, we tested the algorithm on datasets lacking pre-existing meshes.</p>\n      </Section>\n      <Section title=\"Technical Approach\">\n        <p>The technical approach primarily revolves around implementing the Ball Pivot Approximation algorithm as outlined in the referenced paper. This algorithm operates by rolling an imaginary ball along the given point cloud, adding triangles to the mesh where the ball touches three points. Our implementation maintains an advancing front of the constructed mesh, meaning there is a boundary of 'active edges,' separating the so-far constructed mesh from the points which are yet to be incoporated into the mesh. We iteratively finding new triangles to add by pivoting along these boundary edges. Key functions include ballPivot for identifying the first point reached during pivoting, findSeedTriangle for initiating a new front if remaining vertices exist, and join and glue for modifying boundary edge topology. We will discuess these one by one.</p>\n        <p> Firstly, we use the findSeedTriangle function to find a place to initialize the boundary. The important part of finding such a triangle is that the ball defined by the seed triangle must not contain any other point. This search is done in somewhat of a brute force search. Though we ensure to search points that are roughly close to each other, as far away points have a much less likely chance of being valid seed triangles. It should also be noted that findSeedTriangle may be used multiple times if the surface being reconstructed has multiple components. To detect this, we check to see if there are any remaining unused points after the current boundary is finished advancing.</p>\n        <p>Next, we have the <underline>ballPivot</underline> function. This funtions hosts the geometric heart of the algorithm, and is where most of the mathematical calculations are done. BallPivot takes an edge along the current boundary, and identifies the first point in the point cloud that is hit when a ball is rolled along this edge. This is the first step in adding a triangle to the mesh, as it identifies a candidate triangle to add. However, it is not always the case that we add this triangle to the mesh, as it may introduce nonmanifold topology. </p>\n        <p> Finally, if it is decided that the triangle can successfully be added to the mesh, we must update the current boundary to reflect this change. This is where we use join and glue operations. Join is used to add two new edges around the newly added triangle. However, in some instances, this ill end up with the boundary interesting itself. In this case, we use the glue operation to remove this flaw with the boundary, so that we maintain that the other side of a boundary edge is always outside of the currently constructed mesh. </p>\n\n        <p>Besides these functions, we used some data structures to keep track of the details of the algorithm. To start, the point cloud itself is stored as a list of 3D points, and a matching list of surface normals. Throughout the algorithm, we use indices into these lists to refer to points, as opposed to the actual points themselves. This is both for ease of linking a point to its normal, and for the simplicity of identifying points.</p>\n        <p>For the algirithm itself, we used two main data structures. To store the advancing front, we used a list of doubly linked lists of edges. The resaon we need multiple linked lists is that the boundary may split in two during glue operations. Each edge stores its two points, as well as the center of the ball used to define the triangle it is a part of. This center is necessary to know where to start the ball rolling in ballPivot steps. The second data structure we used was a grid of voxels, used for storing the point cloud in a way that allowed for accessing nearby points more easily. Throughout the geometric steps above, (ballPivot and findSeedTriangle), it is only necessary to know the points that are nearby when doing searches. Thus, it would be a large waste of time to do searches across the entire point cloud, when each step is only a local operation. </p>\n        \n        <img src={BP} alt=\"Ball Pivot Illustration\" style={{ display: 'block', margin: '20px auto' }} />\n        <p>On the other hand, Poisson surface reconstruction leverages the principles of implicit surface modeling to generate a smooth and continuous mesh from the input point cloud. By formulating the reconstruction problem as a Poisson equation, the algorithm seeks to find a function that best fits the input points while adhering to certain boundary conditions. This approach is particularly adept at handling noisy or incomplete point cloud data, as it inherently incorporates regularization techniques to ensure robustness and fidelity in the reconstructed mesh.</p>\n        <div className=\"image-container\">\n          <img src={Fish} alt=\"Poisson reconstruction Illustration\" title=\"Possion\" width = \"1000\" height  = \"450\" style={{ display: 'block', margin: '20px auto' }} />\n          <div className=\"tooltip\">Poisson</div>\n        </div>      \n      </Section>\n      <Section title=\"Problems Encountered and Solutions:\">\n        <p>One significant challenge encountered was the debugging process, requiring meticulous attention to detail to resolve issues and ensure the reliability of the algorithm. There were two significant sources for the majority of the difficulty of debugging the algorithm. The first was that for a majority of the algorithm debugging process, we had not yet made a means of visualizing the point cloud itself. This made it difficult to see what was going wrong and to figure out what might be the cause of the mistakes in the algorithm. Once we made a visualization for the point cloud, debugging was significantly sped up. The second cause for headache was a misunderstanding of the polygon mesh to half-edge mesh conversion program we were using out of the box. This led to us trying to fix a problem in the algorithm that didn't exist, per se, when the real issue was a misuse of the mesh visualization aspect of the program.\n        </p>\n        <p>\n        As a general approach to tackle these challenges, a systematic approach to debugging and problem-solving was employed, leveraging collaborative efforts within the project team. Regular testing and validation procedures help identify and address issues in a timely manner, ensuring steady progress towards project goals.</p>\n        <p>\n          Finally, there is a fundamental limitation of the algorithm itself, which has to do with deciding the radius of the ball to use. Essentially, if the radius is too big, then areas of the surface that have tight curvature will not be detected by rolling the ball over (see the image ). Whereas, if the radius is not large enough, it may percieve boundaries of the surface where there aren't any if there are gaps in the point cloud that are bigger than the ball itself.\n        </p>\n      </Section>\n      <Section title=\"Lessons Learned\">\n        <p> Through the development process, valuable lessons have been learned regarding the complexities of mesh reconstruction from point cloud data. The importance of thorough testing and validation, as well as the need for effective communication and collaboration within the project team, has been underscored.\n\n        Additionally, the iterative nature of algorithm development highlights the significance of adaptability and flexibility in responding to challenges and refining the system. These lessons serve as valuable insights for future projects in the field of point cloud to mesh conversion.</p>\n    \n        <p>One important lesson we learned was to devote more time towards planning out the development process before diving straight in to coding the project. Given that we had done this, we would have likely opted to first create a point cloud visualization first, seeing as we could use that for the next step in the development process. Instead, we went first for the interesting, fun part of the project, ultimately leading to a longer and more arduous project experience.\n        </p>\n\n        <p>\n          Perhaps another important lesson we learned was a lesson in scope. Initially, we had plans to do much more with the project, though we did not end up accomplishing these goals. \n        </p>\n        \n      </Section>\n      <Section title=\"Results\">\n        <p>The accompanying point cloud viewer demo showcases visualization capabilities, providing insights into the mesh reconstruction process as well as, animations, and videos of the system are also included.</p>\n        {/* <video src{vid1} alt=\"Vid\" width = '1000' height = '100'/> */}\n\n        <p> Here is a comparison between an mesh, and the reconstructed mesh obtained by running the algorithm on just the vertices of the original mesh:</p>\n        <div>\n          <div className=\"image-container\">\n            <img src={beanOG} alt=\"Poisson reconstruction Illustration\" title=\"Original\" width=\"40%\" height=\"40%\" style={{ display: 'block', margin: '20px auto' }} />\n            <div className=\"tooltip\">original</div>\n          </div>\n          <div className=\"image-container\">\n            <img src={beanReconstructed} alt=\"Poisson reconstruction Illustration\" title=\"Reconstructed\" width=\"40%\" height=\"40%\" style={{ display: 'block', margin: '20px auto' }} />\n            <div className=\"tooltip\">reconstructed</div>\n          </div> \n        </div>\n         \n\n      </Section>\n      <Section title=\"References\">\n      <a href=\"http://mesh.brown.edu/taubin/pdfs/bernardini-etal-tvcg99.pdf\"> The Ball-Pivoting Algorithm for Surface Reconstruction </a>\n      </Section>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}